# 10장 입력 유효성 검사 및 테스트 구조화

## FT 유효성 검사: 빈 작업 아이템 방지

 - 동일한 아이템을 연속해서 넣는다.
 - 빈 아이템을 등록한다.  

다음과 같은 경우를 미연에 방지하도록 하자. 

### 테스트 건너뛰기
리팩터링 시에는 테스트가 모두 통과된 상태에서 진행되는 것이 좋다.  

```
from unittest import skip
[...]

	@skip
	def foo(self):
```

### 기능 테스트를 여러 파일로 분할하기
늘 강조하듯이 한 단계씩 착실히 진행하는 것이 복잡한 작업을 수월하게 만들 수 있다.
### 개별 테스트 파일 실행
다음과 같이 테스트 파일을 개별적으로 실행할 수 있다.

```
$ python manage.py test functional_tests.test_some
```

### FT에 살 붙이기

## 모델-레이어 유효성 검증
### 단위 테스트를 여러 개 파일로 리팩터링하기
### 단위 테스트 모델 유효성 검증과 self.assertRaises 컨텍스트 관리자
### 수상한 Django: 모델 저장은 유효성 검사가 되지 않는다

## 뷰를 통한 모델 유효성 검증
### 테이터베이스에 잘못된 데이터가 저장됐는지 확인

## Django 패턴: 폼 렌더링 뷰와 같은 뷰에서 POST 요청 처리
### 리팩토링: new_item 기능을 view_list로 옮기기
### view_list에서 모델 유효성 검증 구현

## 리팩토링: 하드코딩된 URL 제거
### {% url %} 템플릿 태그
### get_absolute_url을 이용한 리디렉션

#### 테스트 구조화와 리팩터링 팁
테스트 폴더 사용.  
어플리케이션 코드를 여러 개 파일로 나누어 작성하듯이, 테스트도 여러 파일로 나누어 관리하는 것이 좋다.  

 - tests라는 폴더를 이용. (폴더 내에 \_\_init__.py 파일 포함).
 - 기능 테스트는 1)기능 2)사용자 스토리 단위로 테스트를 그룹화.
 - 단위 테스트는, 테스트 대상 코드 파일별로 별도 테스트 파일을 만든다. Django에서는 test\_models.py, test\_views.py, test\_forms.py

실패 테스트 상태에서 리팩터링하지 않는다.

 - 아직 작성하지 않은 코드를 테스트하기 위해 "skip"을 이용할 수 있다.
 - 리팩터링이 필요한 것들을 기록하고, 진행 중인 작업이 끝나면 리팩터링한다.
 - 코드 커밋 때에는 skip을 제거할 것. diff를 이용하여 줄 단위로 검토!